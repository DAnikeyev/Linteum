@using System.Net
@using Linteum.BlazorApp.Components.Notification
@using Linteum.Shared
@using Linteum.Shared.DTO
@using NLog
@inject Config DefaultConfig
@inject MyApiClient ApiClient
@inject LocalStorageService LocalStorageService
@inject NavigationManager Navigation
@inject NotificationService NotificationService

@code {
    [Parameter]
    public EventCallback<bool> CollapseToggled { get; set; }
    [CascadingParameter]
    public NotificationManager? NotificationManager { get; set; }
    private bool _isCollapsed = false;
    private bool _isLoading = true;
    private List<CanvasDto>? _canvases;
    private bool _hasRendered = false;
    private string? _userName = string.Empty;
    private static readonly Logger _nlog = LogManager.GetCurrentClassLogger();

    // single pending unsubscribe at a time
    private string? _pendingCanvasName;
    private CancellationTokenSource? _pendingCts;

    public async Task RefreshCanvases()
    {
        _userName = await LocalStorageService.GetItemAsync<string>(LocalStorageKey.UserName);
        await LoadCanvases();
        StateHasChanged();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && !_hasRendered)
        {
            _hasRendered = true;
            _userName = await LocalStorageService.GetItemAsync<string>(LocalStorageKey.UserName);
            var savedState = await LocalStorageService.GetItemAsync<bool?>(LocalStorageKey.SidebarCollapsed);
            if (savedState.HasValue)
            {
                _isCollapsed = savedState.Value;
                await CollapseToggled.InvokeAsync(_isCollapsed);
            }
            await LoadCanvases();
            StateHasChanged();
        }
    }

    private async Task LoadCanvases()
    {
        _isLoading = true;
        try
        {
            _canvases = await ApiClient.GetSubscribedCanvasesAsync();
        }
        catch (HttpRequestException ex) when (ex.StatusCode == System.Net.HttpStatusCode.Unauthorized)
        {
            await LocalStorageService.ClearAsync();
            Navigation.NavigateTo("/login");
            _canvases = new List<CanvasDto>();
        }
        catch (Exception ex)
        {
            _nlog.Error(ex, "Failed to load subscribed canvases");
            _canvases = new List<CanvasDto>();
        }
        finally
        {
            _isLoading = false;
        }
    }

    private async Task ToggleCollapse()
    {
        _isCollapsed = !_isCollapsed;
        await LocalStorageService.SetItemAsync(LocalStorageKey.SidebarCollapsed, _isCollapsed);
        await CollapseToggled.InvokeAsync(_isCollapsed);
    }

    private void NavigateToCanvas(string canvasName)
    {
        Navigation.NavigateTo($"/canvas/{canvasName}");
    }

    private void GoToAddCanvas()
    {
        Navigation.NavigateTo("/canvas_add");
    }

    private void GoToSubscribeCanvas()
    {
        Navigation.NavigateTo("/canvas_subscribe");
    }
    private void GoToSettings()
    {
        Navigation.NavigateTo("/settings");
    }

    private async Task NotifyAsync(CustomNotification note)
    {
        try
        {
            await NotificationService.Writer.WriteAsync(note);
        }
        catch (Exception ex)
        {
            _nlog.Warn(ex, "NotificationService.Writer.WriteAsync failed");
        }
    }
    
    private static Exception Unwrap(Exception ex)
    {
        while (ex is AggregateException ae && ae.InnerException != null)
            ex = ae.InnerException;
        while (ex.InnerException != null)
            ex = ex.InnerException;
        return ex;
    }
    
    private static string ParseExceptionMessage(Exception ex, string? canvasName = null)
    {
        ex = Unwrap(ex);

        if (ex is HttpRequestException httpEx)
        {
            if (httpEx.StatusCode.HasValue)
            {
                switch (httpEx.StatusCode.Value)
                {
                    case HttpStatusCode.ServiceUnavailable:
                        return "Service is currently unavailable. Please try again later.";
                    case HttpStatusCode.BadRequest:
                        return canvasName is null ? "Bad request." : $"Cannot unsubscribe from {canvasName}.";
                    case HttpStatusCode.NotFound:
                        return "Canvas is not found.";
                    case HttpStatusCode.Unauthorized:
                        return "You are not authorized. Please log in again.";
                    default:
                        return httpEx.Message ?? "Network error occurred.";
                }
            }
            return httpEx.Message ?? "Network error occurred.";
        }

        if (ex is TaskCanceledException)
            return "Request timed out or was canceled.";

        return !string.IsNullOrEmpty(ex.Message) ? ex.Message : "An unexpected error occurred.";
    }
    private async Task OnUnsubscribeClicked(string canvasName)
    {
        if (_pendingCanvasName != canvasName)
        {
            try
            {
                _pendingCts?.Cancel();
                _pendingCts?.Dispose();
            }
            catch (Exception ex)
            {
                _nlog.Warn(ex, "Error while cancelling previous pending unsubscribe CTS");
            }

            _pendingCanvasName = canvasName;

            try
            {
                var note = new CustomNotification { Message = $"Press again to unsubscribe from {canvasName}", Type = NotificationType.Info };
                await NotifyAsync(note);
            }
            catch (Exception ex)
            {
                _nlog.Warn(ex, "Failed to send 'press again' notification");
            }

            _pendingCts = new CancellationTokenSource();
            var ct = _pendingCts.Token;
            _ = Task.Run(async () =>
            {
                try
                {
                    await Task.Delay(3000, ct);
                    await InvokeAsync(() =>
                    {
                        _pendingCanvasName = null;
                        StateHasChanged();
                    });
                }
                catch (TaskCanceledException) { /* expected when canceled */ }
                catch (Exception ex)
                {
                    _nlog.Warn(ex, "Error in pending timeout task");
                }
            });

            await InvokeAsync(StateHasChanged);
            return;
        }

        try
        {
            var success = await ApiClient.UnsubscribeAsync(canvasName);
            if (success)
            {
                var item = _canvases?.FirstOrDefault(c => c.Name == canvasName);
                if (item != null)
                    _canvases?.Remove(item);

                _nlog.Info("Successfully unsubscribed from {0}", canvasName);

                try
                {
                    var note = new CustomNotification { Message = $"Unsubscribed from {canvasName}", Type = NotificationType.Success };
                    await NotifyAsync(note);
                }
                catch (Exception ex)
                {
                    _nlog.Warn(ex, "Failed to send success notification for unsubscribe {0}", canvasName);
                }
            }
        }
        catch (Exception ex)
        {
            _nlog.Error(ex, "Unsubscribe failed for {0}", canvasName);
            var friendly = ParseExceptionMessage(ex, canvasName);
            try
            {
                var note = new CustomNotification { Message = friendly, Type = NotificationType.Error };
                await NotifyAsync(note);
            }
            catch (Exception logEx)
            {
                _nlog.Warn(logEx, "Failed to send error notification after unsubscribe failure for {0}", canvasName);
            }
        }
        finally
        {
            try
            {
                _pendingCts?.Cancel();
                _pendingCts?.Dispose();
            }
            catch (Exception ex)
            {
                _nlog.Warn(ex, "Error while disposing pending CTS in finally");
            }

            _pendingCts = null;
            _pendingCanvasName = null;
            await InvokeAsync(StateHasChanged);
        }
    }

    private bool IsPending(string canvasName) => _pendingCanvasName == canvasName;

    private bool IsHome(string? name) =>
        !string.IsNullOrEmpty(name) && string.Equals(name, DefaultConfig.DefaultCanvasName, StringComparison.OrdinalIgnoreCase);
}
<div class="sidebar @(_isCollapsed ? "collapsed" : "")">
    <div class="sidebar-header">
        <span class="sidebar-username text-truncate" title="@_userName">@(_userName ?? "Guest")</span>
        <button class="btn btn-link p-0 sidebar-cog-btn" title="Settings" @onclick="GoToSettings">
            <img src="images/cog-2.svg" alt="Settings" class="sidebar-cog-img" />
        </button>
    </div>
    <h6 class="sidebar-section-title mb-2 mt-3">Canvases</h6>
    <div class="sidebar-content" style="display:@(_isCollapsed ? "none" : "block");">
        @if (_isLoading)
        {
            <div class="p-3">Loading...</div>
        }
        else if (_canvases == null || _canvases.Count == 0)
        {
            <div class="p-3 text-muted">No canvases</div>
        }
        else
        {
            <ul class="list-group list-group-flush sidebar-canvas-list">

                @foreach (var canvas in _canvases)
                {
                    var isHome = IsHome(canvas.Name);
                    <li class="list-group-item sidebar-canvas-item d-flex justify-content-between align-items-center">
                        <div class="d-flex align-items-center" @onclick="@(() => NavigateToCanvas(canvas.Name))" style="cursor: pointer; flex:1;">
                            <span class="me-2 fs-5">@(isHome ? "üè†" : "üé®") </span>
                            <span class="text-truncate">@canvas.Name</span>
                        </div>
                        <div class="d-flex align-items-center">
                            @if (!isHome)
                            {
                                <button class="btn btn-danger btn-unsubscribe" title="Unsubscribe"
                                        @onclick="async () => await OnUnsubscribeClicked(canvas.Name)"
                                        @onclick:stopPropagation="true">
                                    Unsubscribe
                                </button>
                            }
                        </div>
                    </li>
                }
            </ul>
        }
    </div>
    <div class="sidebar-bottom-actions">
        <button class="btn btn-primary w-100 mb-2" @onclick="GoToAddCanvas">Add new canvas</button>
        <button class="btn btn-outline-primary w-100" @onclick="GoToSubscribeCanvas">Subscribe to canvas</button>
    </div>
</div>
<button class="btn sidebar-collapse-btn @(_isCollapsed ? "collapsed" : "")" @onclick="ToggleCollapse" title="Toggle sidebar">
    <span>@(_isCollapsed ? ">" : "<")</span>
</button>
